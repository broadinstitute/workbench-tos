const test = require('ava');
const sinon = require('sinon');
const GoogleOAuthAuthorizer = require('../authorization');
const GoogleDatastoreClient = require('../datastore');
const { rejection } = require('../responseError');

const tosapi = require('..').tosapi;

process.env.NODE_ENV = 'test';

// mock authorizer that always returns successfully. Normally the authorizer requires an auth token, but this mock
// expects a userinfo object, and echoes that userinfo object back. We do this so different unit tests can specify
// different users, which is important for the datastore mocks below.
class SuccessfulMockAuthorizer extends GoogleOAuthAuthorizer {
    callTokenInfoApi(userinfoStr) {
        // example userinfo: {user_id: 12321, email: 'fake@fakey.fake'}
        return Promise.resolve(JSON.parse(userinfoStr));
    }
}

// START "mock database" - here are the values that we'll be working with in these tests
const applications = {
    FireCloud: {}
}

const toses = {
    20180815.1: {}
}

const userresponses = {
    111: {accepted: true, email: 'one@example.com', userid: 111, timestamp: new Date()},
    222: {accepted: false, email: 'two@example.com', userid: 222, timestamp: new Date()},
    333: {email: 'three@example.com', userid: 333, timestamp: new Date()}
    // 966: reserved - returns an unexpected rejection during the query process
    // 977: reserved - throws an unexpected error during the query process
    // 988: reserved - returns multiple responses for the same user
    // 999: reserved - user has no response
}
// END "mock database"

// mock datastore client that works with the data above
class UnitTestDatastoreClient extends GoogleDatastoreClient {
    
    insertUserResponse(userid, email, appid, tosversion, accepted) {
        if (userid === 966) {
            return Promise.reject(new Error('wow, something went very wrong and I rejected'));
        } else if (userid === 977) {
            throw new Error('wow, something went very wrong and I threw an error');
        } else {
            return Promise.resolve(
                [
                    {
                      "mutationResults": [
                        {
                          "key": {
                            "path": [
                              {
                                "kind": "Application",
                                "name": appid,
                                "idType": "name"
                              },
                              {
                                "kind": "TermsOfService",
                                "name": tosversion.toString(),
                                "idType": "name"
                              },
                              {
                                "kind": "TOSResponse",
                                "id": "1234567", // this is auto-generated by datastore
                                "idType": "id"
                              }
                            ],
                            "partitionId": {
                              "projectId": "unit-test", // will be broad-dsde-dev or whatever env it's running in
                              "namespaceId": "app"
                            }
                          },
                          "version": "987654321", // generated by datastore
                          "conflictDetected": false
                        }
                      ],
                      "indexUpdates": 123 // generated by datastore
                    }
                  ]
            );
        }
    }

    selectApp(appid) {
        const app = applications[appid];
        let hitsArray = [];
        if (app) {
            hitsArray.push(app);
        }
        return Promise.resolve( [ hitsArray, {metadata: 'foo'} ] );
    }

    selectTOS(appid, tosversion) {
        const tos = toses[tosversion];
        let hitsArray = [];
        if (tos) {
            hitsArray.push(tos);
            return Promise.resolve( [ hitsArray, {metadata: 'foo'} ] );
        } else {
            return rejection(400, `TermsOfService ${appid}/${tosversion} does not exist.`)
        }
    }

    selectUserResponse(userid, appid, tosversion) {
        const userresponse = userresponses[userid];
        // results object is an array that contains [0]: array of rows returned; [1]: metadata about the results
        // we ignore the metadata at runtime, so this mock returns a junk object for metadata.
        // if we have TOSResponse in the userresponses map for the user, we return it, otherwise we return []
        let hitsArray = [];

        // handle special error cases
        if (userid === 988) {
            hitsArray.push({accepted: true, email: '988@example.com', userid: 988, timestamp: new Date()});
            hitsArray.push({accepted: false, email: '988@example.com', userid: 988, timestamp: new Date()});
        } else if (userid === 977) {
            throw new Error('wow, something went very wrong and I threw an error');
        } else if (userid === 966) {
            return Promise.reject(new Error('wow, something went very wrong and I rejected'));
        } else if (userresponse) {
            hitsArray.push(userresponse);
        }
        return Promise.resolve( [ hitsArray, {metadata: 'foo'} ] );
    }
}

// helpers to create request/response objects
const stubbedRes = function() {
    return {
        setHeader: sinon.stub(),
        send: sinon.stub(),
        json: sinon.stub(),
        status: sinon.stub().returnsThis()
    };
}

const getRequest = function(userid, appid = 'FireCloud', tosversion = 20180815.1) {
    return {
        path: '/v1/user/response',
        headers: {
            origin: 'unittest',
            authorization: `{"user_id": ${userid}, "email": "fake@fakey.fake"}`
        },
        method: 'GET',
        query: {
            appid: appid,
            tosversion: tosversion
        }
    };
}

const postRequest = function(userid, appid = 'FireCloud', tosversion = 20180815.1, accepted = true, email = 'fake@fakey.fake') {
    return {
        path: '/v1/user/response',
        headers: {
            origin: 'unittest',
            'content-type': 'application/json',
            authorization: `{"user_id": ${userid}, "email": "fake@fakey.fake"}`
        },
        method: 'POST',
        body: {
            appid: appid,
            tosversion: tosversion,
            accepted: accepted
        }
    };
} 

test("GET userresponse: should reject with a 404 if user's TOSResponse doesn't exist", async t => {
    const req = getRequest(999);
    const res = stubbedRes();
        
	const error = await t.throwsAsync( tosapi(req, res, new SuccessfulMockAuthorizer(), new UnitTestDatastoreClient()) );
    t.is(error.statusCode, 404);
    t.is(error.name, 'ResponseError');
    t.is(error.message, 'Error reading user response: 404');
});

test("GET userresponse: should reject with a 403 and 'user declined TOS' if user's TOSResponse has accepted: false", async t => {
    const req = getRequest(222);
    const res = stubbedRes();

	const error = await t.throwsAsync( tosapi(req, res, new SuccessfulMockAuthorizer(), new UnitTestDatastoreClient()) );
    t.is(error.statusCode, 403);
    t.is(error.name, 'ResponseError');
    t.is(error.message, 'Error reading user response: user declined TOS');
});

// TODO: is this the correct response error message?
test("GET userresponse: should reject with a 403 and 'user declined TOS' if user's TOSResponse is missing an accepted value", async t => {
    const req = getRequest(333);
    const res = stubbedRes();

	const error = await t.throwsAsync( tosapi(req, res, new SuccessfulMockAuthorizer(), new UnitTestDatastoreClient()) );
    t.is(error.statusCode, 403);
    t.is(error.name, 'ResponseError');
    t.is(error.message, 'Error reading user response: user declined TOS');
});

test("GET userresponse: should reject with a 500 and 'unexpected: returned too many results' if query somehow returns multiple TOSResponses for the same user", async t => {
    const req = getRequest(988);
    const res = stubbedRes();

	const error = await t.throwsAsync( tosapi(req, res, new SuccessfulMockAuthorizer(), new UnitTestDatastoreClient()) );
    t.is(error.statusCode, 500);
    t.is(error.name, 'ResponseError');
    t.is(error.message, 'Error reading user response: unexpected: returned too many results');
});

test("GET userresponse: should reject with a 500 and 'unexpected error' if the query truly throws an unexpected error", async t => {
    const req = getRequest(977);
    const res = stubbedRes();

	const error = await t.throwsAsync( tosapi(req, res, new SuccessfulMockAuthorizer(), new UnitTestDatastoreClient()) );
    t.is(error.statusCode, 500);
    t.is(error.name, 'ResponseError');
    t.is(error.message, 'Error reading user response: wow, something went very wrong and I threw an error');
});

test("GET userresponse: should reject with a 500 and the rejection's contents if the query truly throws an unexpected rejection", async t => {
    const req = getRequest(966);
    const res = stubbedRes();

	const error = await t.throwsAsync( tosapi(req, res, new SuccessfulMockAuthorizer(), new UnitTestDatastoreClient()) );
    t.is(error.statusCode, 500);
    t.is(error.name, 'ResponseError');
    t.is(error.message, 'Error reading user response: wow, something went very wrong and I rejected');
});

test("GET userresponse: should return TOSResponse object/success if user has exactly 1 TOSresponse and it has accepted:true", async t => {
    const req = getRequest(111);
    const res = stubbedRes();

    return tosapi(req, res, new SuccessfulMockAuthorizer(), new UnitTestDatastoreClient())
        .then( datastoreResult => {
            t.is(datastoreResult.userid, 111);
            t.true(datastoreResult.accepted);
        });
});

test("POST userresponse: should reject with a 400 if the parent Application doesn't exist", async t => {
    const req = postRequest(111, 'unknownApp', 20180815.1);
    const res = stubbedRes();

	const error = await t.throwsAsync( tosapi(req, res, new SuccessfulMockAuthorizer(), new UnitTestDatastoreClient()) );
    t.is(error.statusCode, 400);
    t.is(error.name, 'ResponseError');
    t.is(error.message, 'Error writing user response: Application unknownApp does not exist.');
});

test("POST userresponse: should reject with a 400 if the parent TermsOfService doesn't exist", async t => {
    const req = postRequest(111, 'FireCloud', 99999);
    const res = stubbedRes();

	const error = await t.throwsAsync( tosapi(req, res, new SuccessfulMockAuthorizer(), new UnitTestDatastoreClient()) );
    t.is(error.statusCode, 400);
    t.is(error.name, 'ResponseError');
    t.is(error.message, 'Error writing user response: TermsOfService FireCloud/99999 does not exist.');
});

test("POST userresponse: should reject with a 500 if the insert returned a rejection", async t => {
    const req = postRequest(966);
    const res = stubbedRes();

	const error = await t.throwsAsync( tosapi(req, res, new SuccessfulMockAuthorizer(), new UnitTestDatastoreClient()) );
    t.is(error.statusCode, 500);
    t.is(error.name, 'ResponseError');
    t.is(error.message, 'Error writing user response: wow, something went very wrong and I rejected');
});

test("POST userresponse: should reject with a 500 if the query truly throws an unexpected error", async t => {
    const req = postRequest(977);
    const res = stubbedRes();

	const error = await t.throwsAsync( tosapi(req, res, new SuccessfulMockAuthorizer(), new UnitTestDatastoreClient()) );
    t.is(error.statusCode, 500);
    t.is(error.name, 'ResponseError');
    t.is(error.message, 'Error writing user response: wow, something went very wrong and I threw an error');
});

test("POST userresponse: should return success if all went well", async t => {
    const req = postRequest(111);
    const res = stubbedRes();

    return tosapi(req, res, new SuccessfulMockAuthorizer(), new UnitTestDatastoreClient())
        .then( datastoreResult => {
            t.truthy(datastoreResult);
            t.is(datastoreResult.length, 1);
        });
});
